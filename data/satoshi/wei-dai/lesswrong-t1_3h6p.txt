It's (2), but there is no circularity problem. Idealized Eliezer does not make use of those words in any output, because Idealized Eliezer is a simplified model that only accepts input and outputs a goodness score; it's a function IE(x): statement =&gt; goodness-score. It never outputs words, so it can't use words like "moral" or "should" except inside its own thoughts. It might (but need not) use those words in its own thoughts, but if it does, then those words will mean "what I am eventually going to output", in which case thinking "X is moral" while computing X is equivalent to a return statement, and asking whether Y is moral while computing X is equivalent to recursion.

The circularity you think you've noticed is simply the observation that IE(x)=IE(x). However, this is not a computation that returns, so IE cannot be implemented that way; if it is recursive, it must be a well-founded recursion, that is, all recursive chains resulting from finite input must have finite length. This is formalized in type theory, and we can prove that particular computations are or are not suitable.